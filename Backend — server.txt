Backend â€” server

server/package.json
{
  "name": "admin-chat-backend",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "start": "node index.js",
    "dev": "nodemon index.js"
  },
  "dependencies": {
    "bcryptjs": "^2.4.3",
    "cors": "^2.8.5",
    "dotenv": "^16.0.3",
    "express": "^4.18.2",
    "jsonwebtoken": "^9.0.0",
    "mongoose": "^7.0.3",
    "socket.io": "^4.7.0"
  },
  "devDependencies": {
    "nodemon": "^2.0.22"
  }
}

server/.env.example
PORT=5000
MONGODB_URI=mongodb://localhost:27017/admin_chat
JWT_SECRET=your_jwt_secret_here

server/index.js
require('dotenv').config();
const express = require('express');
const http = require('http');
const mongoose = require('mongoose');
const cors = require('cors');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');
const { Server } = require('socket.io');
const path = require('path');

const authRoutes = require('./routes/auth');
const usersRoutes = require('./routes/users');
const chatRoutes = require('./routes/chat');

const app = express();
const server = http.createServer(app);
const io = new Server(server, { cors: { origin: '*' } });

app.use(cors());
app.use(express.json());

// connect to mongo
mongoose.connect(process.env.MONGODB_URI, { useNewUrlParser: true, useUnifiedTopology: true })
  .then(()=> console.log('MongoDB connected'))
  .catch(err => console.error('MongoDB connection error', err));

// routes
app.use('/api', authRoutes);
app.use('/api', usersRoutes);
app.use('/api', chatRoutes);

// simple health
app.get('/api/health', (req, res) => res.json({ status: 'ok' }));

// --- socket.io ---
io.on('connection', (socket) => {
  console.log('Socket connected', socket.id);

  // join with email (room)
  socket.on('join', ({ email }) => {
    if (!email) return;
    socket.data.email = email;
    socket.join(email);
    console.log(`${email} joined room`);
  });

  // send message event
  socket.on('sendMessage', async (payload) => {
    // payload: { from, to, text }
    const Message = require('./models/Message');
    try {
      const saved = await Message.create({ from: payload.from, to: payload.to, text: payload.text });
      // emit to both sender and receiver rooms
      io.to(payload.to).emit('message', saved);
      io.to(payload.from).emit('message', saved);
    } catch (err) {
      console.error('Save message error', err);
    }
  });

  socket.on('disconnect', () => {
    console.log('Socket disconnected', socket.id);
  });
});

// start server
const PORT = process.env.PORT || 5000;
server.listen(PORT, () => console.log(`Server running on port ${PORT}`));

server/models/User.js
const mongoose = require('mongoose');

const userSchema = new mongoose.Schema({
  name: { type: String, default: '' },
  email: { type: String, unique: true, required: true },
  passwordHash: { type: String, required: true },
  role: { type: String, default: 'user' },
  status: { type: String, default: 'active' },
  lastActive: { type: Date, default: Date.now }
}, { timestamps: true });

module.exports = mongoose.model('User', userSchema);

server/models/Message.js
const mongoose = require('mongoose');

const messageSchema = new mongoose.Schema({
  from: { type: String, required: true },
  to: { type: String, required: true },
  text: { type: String, default: '' },
  delivered: { type: Boolean, default: false },
  read: { type: Boolean, default: false }
}, { timestamps: true });

module.exports = mongoose.model('Message', messageSchema);

server/routes/auth.js
const express = require('express');
const router = express.Router();
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');

const User = require('../models/User');

function generateToken(user) {
  return jwt.sign({ id: user._id, role: user.role, email: user.email }, process.env.JWT_SECRET, { expiresIn: '8h' });
}

// register (demo / admin seeding)
router.post('/register', async (req, res) => {
  const { name, email, password, role } = req.body;
  if (!email || !password) return res.status(400).json({ error: 'Email and password required' });
  try {
    const existing = await User.findOne({ email });
    if (existing) return res.status(400).json({ error: 'Email exists' });
    const passwordHash = await bcrypt.hash(password, 10);
    const user = await User.create({ name, email, passwordHash, role: role || 'user' });
    return res.json({ message: 'User created', userId: user._id });
  } catch (err) { return res.status(500).json({ error: 'Server error' }); }
});

router.post('/login', async (req, res) => {
  const { email, password } = req.body;
  try {
    const user = await User.findOne({ email });
    if (!user) return res.status(401).json({ error: 'Invalid credentials' });
    const ok = await bcrypt.compare(password, user.passwordHash);
    if (!ok) return res.status(401).json({ error: 'Invalid credentials' });
    const token = generateToken(user);
    return res.json({ token, user: { id: user._id, email: user.email, name: user.name, role: user.role } });
  } catch (err) { return res.status(500).json({ error: 'Server error' }); }
});

module.exports = router;

server/routes/users.js
const express = require('express');
const router = express.Router();
const jwt = require('jsonwebtoken');
const User = require('../models/User');

async function authMiddleware(req, res, next) {
  const token = req.headers.authorization?.split(' ')[1];
  if (!token) return res.status(401).json({ error: 'Unauthorized' });
  try {
    const payload = jwt.verify(token, process.env.JWT_SECRET);
    req.user = payload;
    return next();
  } catch (err) { return res.status(401).json({ error: 'Invalid token' }); }
}

router.get('/users', authMiddleware, async (req, res) => {
  const users = await User.find().select('-passwordHash').limit(500).sort({ createdAt: -1 });
  res.json({ users });
});

router.get('/user/:email', authMiddleware, async (req, res) => {
  const email = req.params.email;
  const user = await User.findOne({ email }).select('-passwordHash');
  if (!user) return res.status(404).json({ error: 'User not found' });
  res.json({ user });
});

module.exports = router;

server/routes/chat.js
const express = require('express');
const router = express.Router();
const jwt = require('jsonwebtoken');
const Message = require('../models/Message');

async function authMiddleware(req, res, next) {
  const token = req.headers.authorization?.split(' ')[1];
  if (!token) return res.status(401).json({ error: 'Unauthorized' });
  try {
    const payload = jwt.verify(token, process.env.JWT_SECRET);
    req.user = payload;
    return next();
  } catch (err) { return res.status(401).json({ error: 'Invalid token' }); }
}

// fetch message history for a given email (either user or admin)
router.get('/chat/:email', authMiddleware, async (req, res) => {
  const otherEmail = req.params.email;
  const messages = await Message.find({
    $or: [{ from: otherEmail }, { to: otherEmail }]
  }).sort({ createdAt: 1 }).limit(1000);
  res.json({ messages });
});

// send message via REST (optional additional route)
router.post('/chat/:email', authMiddleware, async (req, res) => {
  const to = req.params.email;
  const { from, text } = req.body;
  try {
    const msg = await Message.create({ from, to, text });
    res.json({ message: 'sent', msg });
  } catch (err) {
    res.status(500).json({ error: 'Failed to send' });
  }
});

module.exports = router;

server/README-server.md (short)
Server (Node.js + Express + Socket.IO)

1. Copy .env.example to .env and set values (MONGODB_URI, JWT_SECRET)
2. Install: npm install
3. Start: npm run dev
4. Create demo admin:
   curl -X POST http://localhost:5000/api/register -H "Content-Type: application/json" -d '{"name":"Admin","email":"admin@example.com","password":"admin123","role":"admin"}'
5. Login:
   curl -X POST http://localhost:5000/api/login -H "Content-Type: application/json" -d '{"email":"admin@example.com","password":"admin123"}'
